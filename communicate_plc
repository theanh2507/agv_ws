import rclpy
from rclpy.node import Node
from pymodbus.client import ModbusSerialClient
from nav_msgs.msg import Odometry
from geometry_msgs.msg import Quaternion
import math
import tf_transformations

class ModbusNode(Node):
    def __init__(self):
        super().__init__("modbus_rtu_node")

        # Kh·ªüi t·∫°o bi·∫øn
        self.right_encoder = 0
        self.left_encoder = 0
        self.prev_right_encoder = 0
        self.prev_left_encoder = 0

        # Th√¥ng s·ªë robot (ƒëi·ªÅu ch·ªânh ph√π h·ª£p)
        self.wheel_radius = 0.05   # B√°n k√≠nh b√°nh xe (m)
        self.wheel_base = 0.3      # Kho·∫£ng c√°ch gi·ªØa 2 b√°nh xe (m)
        self.encoder_resolution = 2048  # S·ªë xung m·ªói v√≤ng

        # T·∫°o Publisher cho /odom
        self.odom_pub = self.create_publisher(Odometry, "/odom", 10)

        # K·∫øt n·ªëi Modbus RTU
        self.declare_parameter("port", "/dev/ttyUSB0")
        self.declare_parameter("baudrate", 9600)
        self.declare_parameter("slave_id", 3)

        self.port = self.get_parameter("port").get_parameter_value().string_value
        self.baudrate = self.get_parameter("baudrate").get_parameter_value().integer_value
        self.slave_id = self.get_parameter("slave_id").get_parameter_value().integer_value

        self.client = ModbusSerialClient(method='rtu', port=self.port, baudrate=self.baudrate, 
                                         parity='N', bytesize=8, stopbits=1, timeout=1)

        if self.client.connect():
            self.get_logger().info("‚úÖ K·∫øt n·ªëi Modbus th√†nh c√¥ng")
        else:
            self.get_logger().error("‚ùå Kh√¥ng th·ªÉ k·∫øt n·ªëi Modbus")

        # Timer ƒë·ªçc d·ªØ li·ªáu v√† g·ª≠i Odom m·ªói 100ms (10Hz)
        self.timer = self.create_timer(0.1, self.read_and_publish_odom)

    def read_and_publish_odom(self):
        """ƒê·ªçc d·ªØ li·ªáu encoder v√† t√≠nh to√°n v·ªã tr√≠"""
        try:
            # ƒê·ªçc encoder t·ª´ PLC
            right_enc_response = self.client.read_holding_registers(0, count=1, slave=self.slave_id)
            left_enc_response = self.client.read_holding_registers(1, count=1, slave=self.slave_id)

            if right_enc_response.isError() or left_enc_response.isError():
                raise ValueError("L·ªói khi ƒë·ªçc encoder t·ª´ PLC")

            # L·∫•y gi√° tr·ªã encoder th·ª±c t·∫ø
            self.right_encoder = right_enc_response.registers[0]
            self.left_encoder = left_enc_response.registers[0]

            # T√≠nh delta encoder
            delta_right = self.right_encoder - self.prev_right_encoder
            delta_left = self.left_encoder - self.prev_left_encoder

            # C·∫≠p nh·∫≠t gi√° tr·ªã c≈©
            self.prev_right_encoder = self.right_encoder
            self.prev_left_encoder = self.left_encoder

            # T√≠nh qu√£ng ƒë∆∞·ªùng t·ª´ng b√°nh xe di chuy·ªÉn
            dist_right = (2 * math.pi * self.wheel_radius * delta_right) / self.encoder_resolution
            dist_left = (2 * math.pi * self.wheel_radius * delta_left) / self.encoder_resolution

            # T√≠nh to√°n v·∫≠n t·ªëc
            v = (dist_right + dist_left) / 2.0
            w = (dist_right - dist_left) / self.wheel_base

            # T·∫°o message Odometry
            odom_msg = Odometry()
            odom_msg.header.stamp = self.get_clock().now().to_msg()
            odom_msg.header.frame_id = "odom"
            odom_msg.child_frame_id = "base_link"

            odom_msg.twist.twist.linear.x = v
            odom_msg.twist.twist.angular.z = w

            # Chuy·ªÉn ƒë·ªïi g√≥c yaw sang quaternion
            quat = tf_transformations.quaternion_from_euler(0, 0, w)
            odom_msg.pose.pose.orientation = Quaternion(*quat)

            # Xu·∫•t d·ªØ li·ªáu
            self.odom_pub.publish(odom_msg)
            self.get_logger().info(f"üì° G·ª≠i Odom: v={v:.3f}, w={w:.3f}")

        except Exception as e:
            self.get_logger().error(f"‚ùå L·ªói ƒë·ªçc encoder ho·∫∑c g·ª≠i Odom: {e}")

def main(args=None):
    rclpy.init(args=args)
    node = ModbusNode()
    rclpy.spin(node)
    node.destroy_node()
    rclpy.shutdown()

if __name__ == "__main__":
    main()
